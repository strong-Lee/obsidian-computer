## 1. 基础常用
1. **去重：** list(set(lst)) 最经典的去重。
2. **创建空集合：** 必须用 set()，因为 {} 是字典。
3. **添加元素：** s.add(x)。
4. **移除元素：** s.remove(x) (不存在报错)。
5. **安全移除：** s.discard(x) (不存在不报错)。
6. **交集：** s1 & s2。
7. **并集：** s1 | s2。
8. **差集：** s1 - s2 (在 s1 但不在 s2)。
9. **对称差集：** s1 ^ s2 (不同时在两个集合中)。
10. **成员检查：** x in s (O(1) 复杂度)。
## 2. 进阶高级
1. **集合推导式：** {x for x in range(10) if x > 5}。
2. **子集判断：** s1.issubset(s2) 或 s1 <= s2。
3. **超集判断：** s1.issuperset(s2) 或 s1 >= s2。
4. **不可变集合：** frozenset(lst)，可以作为字典的 Key。
5. **批量更新：** s.update(lst) 一次添加多个。
6. **消除列表重复并保持顺序：** list(dict.fromkeys(lst)) (借用字典键的唯一性和有序性，比 set 强)。
7. **pop() 的随机性：** s.pop() 移除并返回任意元素（用于任务池）。
8. **判断无交集：** s1.isdisjoint(s2)。
9. **集合运算用于逻辑流：** 用集合差集快速找出“缺失的数据”或“新增的数据”。
10. **参数去重：** 函数定义 def func(*args): args = set(args)。

## 3. 黑客技巧
1. **O(1) 查找表：** 将巨大的列表转为 set，查找速度提升几千倍（空间换时间）。
2. **布尔运算底层：** 集合的 & | 运算符重载，代码看起来像位运算。
3. **集合内的哈希规则：** 集合元素必须是 Hashable 的，不能放 list 或 dict。
4. **sys.intern 配合集合：** 存储大量字符串时，先 intern 再存入 set 节省内存。
5. **集合字面量优化：** 编译器会将 {1, 2, 3} 编译为常量集合（frozenset），比 set([1, 2, 3]) 加载更快。
6. **利用 ^ 做开关：** states ^ {current} 快速切换状态（如果只有两种状态）。
7. **JSON 数组标准化：** 比较两个 JSON 数组是否包含相同元素（忽略顺序），转 set 比较。
8. **集合算术消除 if：** active_users &= valid_users (仅保留有效用户)。
9. **实现 Bloom Filter：** 虽然 set 精确，但对于海量数据，可用 bitarray 模拟 set 实现布隆过滤器。
10. **Disassembler 查看：** 用 dis 模块看 x in {1, 2, 3} 实际上被优化成了 COMPARE_OP。