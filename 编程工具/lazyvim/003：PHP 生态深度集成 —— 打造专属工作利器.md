	现在，我们开始针对 PHP 开发进行深度定制。LazyVim 通过 extras 概念简化了语言支持的安装。

### 步骤 1：启用 PHP "全家桶"

	LazyVim 已为 PHP 准备好了包含 LSP、格式化、语法高亮的全套配置，我们只需“翻个开关”。

1. 创建一个lsp-php.lua新文件 (我们把 PHP 相关的配置都放在这里，保持整洁)。

2. 粘贴以下内容：
```lua
-- ~/.config/nvim/lua/plugins/lsp-php.lua
return {
  -- ★ 核心：启用 LazyVim 的 PHP 模块
  {
    "LazyVim/LazyVim",
    opts = function(_, opts)
      -- 确保 opts.extras 存在且是 table
      opts.extras = opts.extras or {}
      -- 安全地添加 PHP 支持
      vim.list_extend(opts.extras, {
        "lang.php",
      })
    end,
  },
  -- ★ 确保 PHP 工具由 Mason 自动安装
  {
    "williamboman/mason.nvim",
    opts = function(_, opts)
      -- 添加安全初始化
      opts.ensure_installed = opts.ensure_installed or {}
      vim.list_extend(opts.ensure_installed, {
        "intelephense", -- PHP 的 LSP 服务器
        "php-cs-fixer", -- PHP 的代码格式化器
        "phpstan", -- 建议添加：静态分析
        -- "psalm", -- 建议添加：类型检查, php版本大于8.1
        "php-debug-adapter",  -- 调试支持
        "blade-formatter",    -- Laravel Blade 支持
      })
    end,
  },
  -- ★ PHP 专用增强
  {
    "adalessa/laravel.nvim",
    dependencies = {
      "nvim-telescope/telescope.nvim",
      "tpope/vim-dotenv",
    },
    cmd = { "Sail", "Artisan", "Composer", "Npm", "Yarn", "Laravel" },
    keys = {
      { "<leader>la", ":Laravel artisan<cr>" },
      { "<leader>lr", ":Laravel routes<cr>" },
    },
    config = function()
      require("laravel").setup()
      require("telescope").load_extension("laravel")
    end,
  },
}

```

	保存文件后，重启 nvim。Mason 会自动开始在后台安装 intelephense 和 php-cs-fixer。你可以通过 :Mason 命令查看安装进度和状态。

### 模块深度解析

#### A. LSP (Intelephense): 你的代码智能大脑

- **功能**: 这是你获得代码智能（自动补全、错误提示、跳转定义）的核心。它通过 intelephense 这个“PHP 大脑”来实时分析你的代码。
    
- **优点**:
    
    1. **智能感知**: 提供基于项目上下文的、类型安全的自动补全。
        
    2. **实时诊断**: 实时高亮语法错误、未定义变量、类型不匹配等问题。
        
    3. **代码导航**: gd (跳转定义), gr (查找引用) 让你在代码库中自由穿梭。
        
    4. **安全重构**: <Space> c r (**C**ode **R**ename) 安全地重命名变量/方法/类。
        
- **注意事项**:
    
    - **在项目根目录启动!** 请始终在项目根目录（有 composer.json 的地方）执行 nvim .。LSP 需要它来确定工作区。
        
    - **务必 composer install!** LSP 需要读取 vendor 目录来分析依赖库，否则它不认识你项目里的类。
        
    - **许可证**: Intelephense 免费版功能已覆盖 95% 的日常需求。高级功能（如查找接口实现）需要付费。
        

#### B. 格式化 (Conform.nvim + php-cs-fixer): 你的代码洁癖助手

	你的需求是手动格式化，而不是保存时自动格式化。LazyVim 默认是保存时格式化，我们需要覆盖它。

1. 创建新文件 formatter-php.lua。
    
2. 粘贴以下配置：

```lua
-- ~/.config/nvim/lua/plugins/formatter-php.lua
return {
  {
    "stevearc/conform.nvim",
    -- 覆盖 conform.nvim 的默认设置
    opts = {
      -- ★ 核心：关闭保存时自动格式化 
      format_on_save = false,
      -- ★ 定义格式化器配置
      formatters = {
        ["php-cs-fixer"] = {
          command = "php-cs-fixer",
          args = {
            "--no-interaction",
            "--quiet",
            "fix",
            "$FILENAME"
          },
          cwd = require("conform.util").root_file({ "composer.json", ".php-cs-fixer.php" }),
        },
      },
	  -- ★ 文件类型映射
      formatters_by_ft = {
        php = { "php-cs-fixer" },
        -- 你也可以在这里为其他语言添加格式化器
        -- lua = { "stylua" },
      },
    },
  },
  -- ★增强版快捷键配置（直接放在基础键位）
  {
    "LazyVim/LazyVim",
    init = function()
      -- 更安全的格式化函数
      local function safe_format()
        local buf = vim.api.nvim_get_current_buf()
        if vim.bo[buf].modified then
          vim.notify("⚠️ 保存修改后再格式化", vim.log.levels.WARN)
          return
        end
        
        require("conform").format({
          async = true,
          lsp_fallback = true,
          timeout_ms = 3000,
        })
        
        vim.notify("✅ 代码已格式化", vim.log.levels.INFO)
      end
      
      -- 注册快捷键
      vim.keymap.set({ "n", "v" }, "<leader>cf", safe_format, {
        desc = "格式化代码"
      })
    end,
  },
  -- ★ PHP-CS-Fixer 配置示例（可选）
  {
    "mfussenegger/nvim-lint",
    opts = {
      linters_by_ft = {
        php = { "phpcs" } -- 可搭配代码检查
      },
    },
  },
}
```

> [!TIP]  
> **项目级规则是王道！**  
> 为了获得最佳且一致的格式化效果，在你的 PHP 项目根目录下创建一个 .php-cs-fixer.dist.php 文件。这是一个很好的模板：

```php
$rules = [
    '@PSR12' => true,
    'array_syntax' => ['syntax' => 'short'],
    'binary_operator_spaces' => ['operators' => ['=>' => 'align']],
];

// PHP 7.4 兼容配置
$config = new PhpCsFixer\Config();
return $config
    ->setRiskyAllowed(true)
    ->setRules($rules)
    ->setUsingCache(false)
    ->setIndent("    ");
```

#### C. 代码片段 (LuaSnip): 你的编码加速器

	代码片段可以让你用简短的触发词快速插入常用代码模板。LazyVim 已内置 LuaSnip 和一套通用代码片段。我们可以轻松添加自己的 PHP 片段。
	
- **如何使用?**
    
    - 在 PHP 文件中，输入 class，然后你的补全菜单中会出现一个带片段图标的选项，选择它就会展开一个类模板。
        
    - 输入 fun，展开为 function name(args) { ... }。
        
    - 如果片段有多个可编辑区域，使用 Tab 或 Ctrl+j/k 在它们之间跳转。
	
- **自定义片段**: 这是非常强大的功能。

	- 1. 创建目录 ~/.config/nvim/snippets/php.snippets (如果使用的是 friendly-snippets 的话)。
    
	- 2. 或者，更推荐的方式是使用 Lua 来定义。创建 lua/plugins/snippets.lua：

1. 创建新文件 ~/.config/nvim/lua/plugins/snippets.lua。
    
2. 粘贴以下配置：

```lua
-- ~/.config/nvim/lua/plugins/snippets.lua

return {
  -- 我们告诉 LazyVim，我们想对 "LuaSnip" 这个插件进行一些修改
  {
    "L3MON4D3/LuaSnip",
    -- 我们不使用 config 函数了，而是使用 `opts` table。
    -- `opts` 会在插件默认配置加载后，智能地与之合并，这是更安全的方式。
    opts = function(_, opts)
      -- `opts` 参数是 LazyVim 传递过来的默认配置，我们可以在此基础上修改。
      -- 我们要做的就是加载我们自己的片段文件。
      -- `luasnip.loaders.from_lua` 是 LuaSnip 官方推荐的加载方式。
      require("luasnip.loaders.from_lua").load({ paths = "~/.config/nvim/lua/custom-snippets" })
    end,
  },
}

# 创建存放片段的目录
mkdir -p ~/.config/nvim/lua/custom-snippets

# 创建一个专门用于存放 PHP 片段的文件
touch ~/.config/nvim/lua/custom-snippets/php.lua

-- ~/.config/nvim/lua/custom-snippets/php.lua

-- 引入 luasnip 的核心函数
local ls = require("luasnip")
local s = ls.snippet
local i = ls.insert_node
local t = ls.text_node

-- 返回一个包含所有片段的 table
return {
  -- 触发词: pubf
  s("pubf", {
    t({ "public function " }),
    i(1, "methodName"), -- 第一个光标停留点
    t({ "()" }),
    t({ "" }),
    t({ "{" }),
    t({ "    " }),
    i(0), -- 最后一个光标停留点 (按 Tab 跳转至此)
    t({ "" }),
    t({ "}" }),
  }),

  -- 触发词: pdo
  s("pdo", {
    t({ '$dsn = "mysql:host=localhost;dbname=test;charset=utf8";' }),
    t({ '$username = "root";' }),
    t({ '$password = "";' }),
    t({ "" }),
    t({ "try {" }),
    t({ '    $pdo = new PDO($dsn, $username, $password);' }),
    t({ '    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);' }),
    t({ "    " }),
    i(0),
    t({ "} catch (PDOException $e) {" }),
    t({ '    echo "Connection failed: " . $e->getMessage();' }),
    t({ "}" }),
  }),
}
```

	如何使用? 在一个 PHP 文件中，输入 pubf，然后按 <Tab> 或 <Enter>，它就会展开成一个公共函数模板，光标会自动定位到 methodName 处让你输入，写完后再按 <Tab>，光标会跳到函数体内部。
	
---

下一章：[[004：注入 AI 灵魂 —— 免费的 "Cursor" 体验]]

#lazyvim 