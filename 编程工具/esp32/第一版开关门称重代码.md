```C++
#include "HX711.h"

#include <Preferences.h>

#include <esp_task_wdt.h> // 引入看门狗库

  

// --- (硬件引脚定义不变) ---

#define RPWM_PIN 18

#define LPWM_PIN 19

#define R_IS_PIN 34 // 伸展/关门

#define L_IS_PIN 35 // 收缩/开门

#define LOADCELL_DOUT_PIN 25

#define LOADCELL_SCK_PIN 26

#define WDT_TIMEOUT 60 // 60秒超时

  

// --- 核心参数 (V5.0 全新策略) ---

#define TRAVEL_TIME 5500 // 【精确】拉杆完整行程时间(毫秒)，我们用5.5秒

#define STARTUP_TIMEOUT 500 // 启动检测超时(0.5秒)

#define END_CONFIRM_COUNT 8 // 结束时确认电流归零的次数

#define MIN_RUNNING_CURRENT 50 // 判断电机是否在“运行”的最低电流阈值

#define EXTEND_ABNORMAL_CURRENT 7000 // 伸展(关门)时的异常保护阈值

#define RETRACT_ABNORMAL_CURRENT 7000 // 收缩(开门)时的异常保护阈值 (设得很高以避开启动尖峰)

#define CALIBRATION_STANDARD_WEIGHT 217.0

  

// --- 动作执行结果状态码 ---

enum ActionResult {

SUCCESS_OPENED, // 成功开门

SUCCESS_CLOSED, // 成功关门

ERROR_STARTUP_FAILED, // 启动失败

ERROR_ABNORMAL_CURRENT, // 异常电流

ERROR_TIMEOUT // 超时

};

  

// --- (全局变量和对象创建不变) ---

float calibration_factor;

HX711 scale;

Preferences preferences;

  

// --- (函数声明更新) ---

void stopMotor();

ActionResult motorAction(bool isOpening); // 返回值改为精确的状态码

void openDoor();

void closeDoor();

void getWeight();

void startCalibration();

void saveCalibration();

  

void setup() {

Serial.begin(115200);

Serial.println("\n\n智能回收柜控制系统 v5.1");

  

// 初始化并启动看门狗

esp_task_wdt_config_t wdt_config = {

.timeout_ms = WDT_TIMEOUT * 1000, // 超时时间，单位是毫秒

.idle_core_mask = (1 << 0) | (1 << 1), // 监控两个核心的空闲任务

.trigger_panic = true, // 超时后触发内核恐慌（重启）

};

esp_task_wdt_init(&wdt_config); // 传入配置结构体的地址

esp_task_wdt_add(NULL); // 将当前任务(loop)添加到看门狗监控列表

  

preferences.begin("trash-cal", false);

calibration_factor = preferences.getFloat("cal_factor", 420.0);

Serial.print("校准系数已加载: "); Serial.println(calibration_factor);

  

pinMode(RPWM_PIN, OUTPUT);

pinMode(LPWM_PIN, OUTPUT);

stopMotor();

  

scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);

scale.set_scale(calibration_factor);

scale.tare();

Serial.println("系统初始化完成。正在执行上电复位...");

// --- 执行开机复位关门程序 ---

ActionResult result = motorAction(false); // false代表关门

  

// 根据复位结果打印最终状态

switch(result) {

case SUCCESS_CLOSED:

Serial.println("上电复位成功: 门已确认关闭。");

break;

case ERROR_STARTUP_FAILED:

Serial.println("严重警告: 上电复位失败 (电机启动无反应)！");

break;

case ERROR_ABNORMAL_CURRENT:

Serial.println("严重警告: 上电复位失败 (检测到异常电流)！");

break;

case ERROR_TIMEOUT:

Serial.println("严重警告: 上电复位失败 (执行超时)！");

break;

default:

Serial.println("严重警告: 上电复位失败 (未知错误)！");

}

Serial.println("系统准备就绪。可用指令: open, close, weight, start_cal, save_cal");

}

  

void loop() {

if (Serial.available() > 0) {

String command = Serial.readStringUntil('\n'); command.trim();

if (command == "open") { openDoor(); }

else if (command == "close") { closeDoor(); }

else if (command == "weight") { getWeight(); }

else if (command == "start_cal") { startCalibration(); }

else if (command == "save_cal") { saveCalibration(); }

else { Serial.println("未知指令!"); }

}

esp_task_wdt_reset();

}

  

// --- 核心功能函数 (V5.1 终极哲学重构) ---

  

ActionResult motorAction(bool isOpening) {

unsigned long startTime = millis();

int current_pin = isOpening ? L_IS_PIN : R_IS_PIN;

int abnormal_threshold = isOpening ? RETRACT_ABNORMAL_CURRENT : EXTEND_ABNORMAL_CURRENT;

  

if (isOpening) { Serial.println("STATUS:OPENING"); digitalWrite(RPWM_PIN, LOW); digitalWrite(LPWM_PIN, HIGH); }

else { Serial.println("STATUS:CLOSING"); digitalWrite(RPWM_PIN, HIGH); digitalWrite(LPWM_PIN, LOW); }

  

// 阶段一：启动检测

while (millis() - startTime < STARTUP_TIMEOUT) {

if (analogRead(current_pin) > MIN_RUNNING_CURRENT) {

goto RUNNING_PHASE;

}

esp_task_wdt_reset();

delay(20);

}

stopMotor();

return ERROR_STARTUP_FAILED;

  

RUNNING_PHASE:

// 阶段二：运行监控

while (millis() - startTime < TRAVEL_TIME) {

if (analogRead(current_pin) > abnormal_threshold) {

stopMotor();

return ERROR_ABNORMAL_CURRENT;

}

esp_task_wdt_reset();

delay(20);

}

  

// 阶段三：结束确认

int zero_counter = 0;

unsigned long end_check_start = millis();

while(millis() - end_check_start < 1000) { // 最多再花1秒钟确认电流归零

if (analogRead(current_pin) < MIN_RUNNING_CURRENT) {

zero_counter++;

} else {

zero_counter = 0;

}

if(zero_counter >= END_CONFIRM_COUNT) {

stopMotor();

return isOpening ? SUCCESS_OPENED : SUCCESS_CLOSED;

}

esp_task_wdt_reset();

delay(20);

}

// 如果时间到了，但电流还未归零，也认为是超时的一种

stopMotor();

return ERROR_TIMEOUT;

}

  

void openDoor() {

Serial.println("指令: 开门 (拉杆收缩)...");

ActionResult result = motorAction(true);

// 根据执行结果，向外报告最终状态

switch(result) {

case SUCCESS_OPENED:

Serial.println("REPORT:DOOR_OPENED");

break;

case ERROR_STARTUP_FAILED:

Serial.println("REPORT:ERROR_STARTUP_FAILED");

break;

case ERROR_ABNORMAL_CURRENT:

Serial.println("REPORT:ERROR_ABNORMAL_CURRENT");

break;

case ERROR_TIMEOUT:

Serial.println("REPORT:ERROR_TIMEOUT");

break;

default:

Serial.println("REPORT:ERROR_UNKNOWN");

}

}

  

void closeDoor() {

Serial.println("指令: 关门 (拉杆伸展)...");

ActionResult result = motorAction(false);

switch(result) {

case SUCCESS_CLOSED:

Serial.println("REPORT:DOOR_CLOSED");

break;

// ... (其他错误报告同上)

case ERROR_STARTUP_FAILED: Serial.println("REPORT:ERROR_STARTUP_FAILED"); break;

case ERROR_ABNORMAL_CURRENT: Serial.println("REPORT:ERROR_ABNORMAL_CURRENT"); break;

case ERROR_TIMEOUT: Serial.println("REPORT:ERROR_TIMEOUT"); break;

default: Serial.println("REPORT:ERROR_UNKNOWN");

}

}

  

void stopMotor() {

digitalWrite(RPWM_PIN, LOW);

digitalWrite(LPWM_PIN, LOW);

}

  

void getWeight() {

float weight = scale.get_units(10); if (abs(weight) < 20) { weight = 0.0; }

Serial.print("当前重量: "); Serial.print(weight, 1); Serial.println(" g");

}

void startCalibration() {

Serial.println("\n--- 开始校准流程 ---"); Serial.println("1. 请确保秤盘清空。"); scale.tare();

Serial.print("2. 已去皮。请将 "); Serial.print(CALIBRATION_STANDARD_WEIGHT, 1); Serial.println("g 的标准物品放在秤盘上。");

Serial.println("3. 放置好后，请输入指令 'save_cal' 来保存。");

}

void saveCalibration() {

long raw_reading = scale.get_value(10);

calibration_factor = (float)raw_reading / CALIBRATION_STANDARD_WEIGHT;

scale.set_scale(calibration_factor); preferences.putFloat("cal_factor", calibration_factor);

Serial.print("校准完成！新系数 "); Serial.print(calibration_factor); Serial.println(" 已被永久保存。");

}
```