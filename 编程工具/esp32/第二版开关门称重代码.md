```c++
#include "HX711.h" // 引入HX711称重传感器库

#include <Preferences.h> // 引入ESP32的Flash非易失性存储库，用于永久保存校准系数

#include <esp_task_wdt.h> // 引入ESP32的任务看门狗库，防止程序卡死

  

// --- 硬件引脚定义 ---

#define RPWM_PIN 18 // 电机驱动板的正转信号引脚

#define LPWM_PIN 19 // 电机驱动板的反转信号引脚

#define R_IS_PIN 34 // 电流检测引脚：对应伸展/关门动作 (R_IS)

#define L_IS_PIN 35 // 电流检测引脚：对应收缩/开门动作 (L_IS)

#define LOADCELL_DOUT_PIN 25 // HX711称重传感器的数据输出引脚 (DT)

#define LOADCELL_SCK_PIN 26 // HX711称重传感器的时钟引脚 (SCK)

#define WDT_TIMEOUT 60 // 看门狗超时时间(秒)，如果60秒内主循环没响应，系统会自动重启

  

// --- 核心参数 (V6.1) ---

#define TRAVEL_TIME 5500 // 【可调】拉杆从一端到另一端的完整行程时间(毫秒)

#define STARTUP_TIMEOUT 500 // 【可调】电机启动后，检测电流是否出现的超时时间(毫秒)

#define END_CONFIRM_COUNT 8 // 【可调】行程结束时，需要连续检测到多少次“零电流”才算真正停止

#define MIN_RUNNING_CURRENT 50 // 【可调】判断电机是否在“运行”的最低电流ADC读数阈值

#define EXTEND_ABNORMAL_CURRENT 7000 // 【可调】伸展(关门)时的异常大电流保护阈值 (ADC读数)

#define RETRACT_ABNORMAL_CURRENT 7000 // 【可调】收缩(开门)时的异常大电流保护阈值 (ADC读数)

#define CALIBRATION_STANDARD_WEIGHT 217.0 // 【重要】用于校准的砝码重量(克)，这里用的是一个苹果手机的重量

  

// --- (全局变量和对象创建) ---

float calibration_factor; // 用于存储校准系数

HX711 scale; // 创建一个称重传感器对象

Preferences preferences; // 创建一个Flash存储对象

  

// --- (状态机核心变量) ---

// 定义电机所有可能的状态

enum MotorState {

IDLE, // 空闲

STARTING_OPEN, // 正在启动开门

RUNNING_OPEN, // 正在运行开门

ENDING_OPEN, // 正在结束开门

STARTING_CLOSE, // 正在启动关门

RUNNING_CLOSE, // 正在运行关门

ENDING_CLOSE // 正在结束关门

};

// 定义一个变量来存储电机当前的状态，程序启动时默认为空闲

MotorState currentMotorState = IDLE;

  

// 时间戳变量，用于非阻塞式延时和超时判断

unsigned long motorActionStartTime = 0; // 记录整个电机动作（从启动到结束）的起始时间戳

unsigned long stateChangeTime = 0; // 记录每次状态切换时的时间戳

  

// 用于结束确认的计数器

int zero_counter = 0;

  

// --- (函数声明) ---

void stopMotor();

void startMotorAction(bool isOpening); // “启动任务”的函数

void updateMotorState(); // “更新状态”的核心函数

// 状态处理函数

void handleStartingOpenState();

void handleRunningOpenState();

void handleEndingOpenState();

void handleStartingCloseState();

void handleRunningCloseState();

void handleEndingCloseState();

// 操作函数

void openDoor();

void closeDoor();

void getWeight();

void startCalibration();

void saveCalibration();

  

void setup() {

Serial.begin(115200);

Serial.println("\n\n智能回收柜控制系统 v6.1(函数式状态机版)");

  

// 初始化并启动看门狗

esp_task_wdt_config_t wdt_config = {

.timeout_ms = WDT_TIMEOUT * 1000, // 超时时间，单位是毫秒

.idle_core_mask = (1 << 0) | (1 << 1), // 监控两个核心的空闲任务

.trigger_panic = true, // 超时后触发内核恐慌（重启）

};

esp_task_wdt_init(&wdt_config); // 传入配置结构体的地址

esp_task_wdt_add(NULL); // 将当前任务(loop)添加到看门狗监控列表

  

// --- 初始化Flash存储 ---

preferences.begin("trash-cal", false); // 打开名为"trash-cal"的存储空间

// 读取之前保存的校准系数，如果不存在，则使用一个默认值420.0

calibration_factor = preferences.getFloat("cal_factor", 420.0);

Serial.print("校准系数已加载: "); Serial.println(calibration_factor);

  

// --- 初始化电机引脚 ---

pinMode(RPWM_PIN, OUTPUT);

pinMode(LPWM_PIN, OUTPUT);

stopMotor(); // 确保开机时电机是停止的

  

// --- 初始化称重传感器 ---

scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN); // 启动传感器

scale.set_scale(calibration_factor); // 设置校准系数

scale.tare(); // 开机去皮，将当前重量清零

// --- 执行上电复位程序 ---

Serial.println("系统初始化完成。正在执行上电复位...");

startMotorAction(false); // false代表启动一个“关门”任务

}

  

void loop() {

// 1. 喂狗：每次循环都重置看门狗计时器，表示程序运行正常

esp_task_wdt_reset();

  

// 2. 检查串口指令 (非阻塞)：检查电脑是否发来新指令

if (Serial.available() > 0) {

String command = Serial.readStringUntil('\n'); command.trim();

if (command == "open") { openDoor(); }

else if (command == "close") { closeDoor(); }

else if (command == "weight") { getWeight(); }

else if (command == "start_cal") { startCalibration(); }

else if (command == "save_cal") { saveCalibration(); }

else { Serial.println("未知指令!"); }

}

  

// 3. 更新电机的状态 (整个状态机的核心驱动！)

updateMotorState();

  

// 4. (未来可以在这里加其他任务，比如更新MP3播放状态，读取激光距离等)

// delay(10); // 可以加一个极短的延时，给其他任务一点喘息时间，也可不加

}

  

void updateMotorState() {

// 如果当前电机是空闲的，就什么都不做，直接返回，节省CPU资源

if (currentMotorState == IDLE) {

return;

}

  

// 根据当前的状态，调用对应的处理函数

switch (currentMotorState) {

case STARTING_OPEN: handleStartingOpenState(); break;

case RUNNING_OPEN: handleRunningOpenState(); break;

case ENDING_OPEN: handleEndingOpenState(); break;

case STARTING_CLOSE: handleStartingCloseState(); break;

case RUNNING_CLOSE: handleRunningCloseState(); break;

case ENDING_CLOSE: handleEndingCloseState(); break;

default:

// 理论上不应该进入这里，可以加个日志以防万一

break;

}

}

  

// 状态处理函数实现

// --- 开门过程的状态处理 ---

void handleStartingOpenState() {

// 检查：电流是否已超过启动阈值？

if (analogRead(L_IS_PIN) > MIN_RUNNING_CURRENT) {

currentMotorState = RUNNING_OPEN; // 状态切换：启动成功 -> 运行中

stateChangeTime = millis(); // 记录进入运行状态的时间点

// 检查：启动是否已超时？

} else if (millis() - motorActionStartTime > STARTUP_TIMEOUT) {

stopMotor();

currentMotorState = IDLE; // 状态切换：回到空闲

Serial.println("REPORT:ERROR_STARTUP_FAILED");

}

}

  

void handleRunningOpenState() {

// 检查：是否出现异常大电流？

if (analogRead(L_IS_PIN) > RETRACT_ABNORMAL_CURRENT) {

stopMotor();

currentMotorState = IDLE;

Serial.println("REPORT:ERROR_ABNORMAL_CURRENT");

// 检查：是否已达到预设的行程时间？

} else if (millis() - motorActionStartTime > TRAVEL_TIME) {

currentMotorState = ENDING_OPEN; // 状态切换：运行中 -> 结束确认

stateChangeTime = millis(); // 记录进入结束确认状态的时间点

zero_counter = 0; // 清零计数器

}

}

  

void handleEndingOpenState() {

// 检查：电流是否已回落到阈值以下？

if (analogRead(L_IS_PIN) < MIN_RUNNING_CURRENT) {

zero_counter++; // 是，则计数器加一

} else {

zero_counter = 0; // 否，则清零计数器，防止误判

}

// 检查：是否已连续多次检测到低电流？

if (zero_counter >= END_CONFIRM_COUNT) {

stopMotor();

currentMotorState = IDLE;

Serial.println("REPORT:DOOR_OPENED");

// 检查：结束确认过程是否已超时？

} else if (millis() - stateChangeTime > 1000) {

stopMotor();

currentMotorState = IDLE;

Serial.println("REPORT:ERROR_TIMEOUT");

}

}

  

// --- 关门过程的状态处理 (逻辑与开门对称) ---

void handleStartingCloseState() {

if (analogRead(R_IS_PIN) > MIN_RUNNING_CURRENT) {

currentMotorState = RUNNING_CLOSE;

stateChangeTime = millis();

} else if (millis() - motorActionStartTime > STARTUP_TIMEOUT) {

stopMotor();

currentMotorState = IDLE;

// 特殊判断：如果是刚开机时的复位失败，打印更详细的警告

if (millis() < 10000) {

Serial.println("严重警告: 上电复位失败 (电机启动无反应)！");

} else {

Serial.println("REPORT:ERROR_STARTUP_FAILED");

}

}

}

  

void handleRunningCloseState() {

if (analogRead(R_IS_PIN) > EXTEND_ABNORMAL_CURRENT) {

stopMotor();

currentMotorState = IDLE;

Serial.println("REPORT:ERROR_ABNORMAL_CURRENT");

} else if (millis() - motorActionStartTime > TRAVEL_TIME) {

currentMotorState = ENDING_CLOSE;

stateChangeTime = millis();

zero_counter = 0;

}

}

  

void handleEndingCloseState() {

if (analogRead(R_IS_PIN) < MIN_RUNNING_CURRENT) {

zero_counter++;

} else {

zero_counter = 0;

}

if (zero_counter >= END_CONFIRM_COUNT) {

stopMotor();

currentMotorState = IDLE;

// 特殊判断：如果是刚开机时的复位成功，打印更友好的提示

if (millis() < 10000) {

Serial.println("上电复位成功: 门已确认关闭。");

} else {

Serial.println("REPORT:DOOR_CLOSED");

}

} else if (millis() - stateChangeTime > 1000) {

stopMotor();

currentMotorState = IDLE;

Serial.println("REPORT:ERROR_TIMEOUT");

}

}

  

/**

* @brief 启动一个电机动作（开门或关门）

* @param isOpening true代表开门，false代表关门

*/

void startMotorAction(bool isOpening) {

// 如果电机当前正在忙，则拒绝新指令，防止指令冲突

if (currentMotorState != IDLE) {

Serial.println("电机正忙，请稍后...");

return;

}

motorActionStartTime = millis(); // 记录任务开始的总时间戳

  

if (isOpening) {

Serial.println("STATUS:OPENING");

digitalWrite(RPWM_PIN, LOW);

digitalWrite(LPWM_PIN, HIGH);

currentMotorState = STARTING_OPEN; // 设置初始状态为“正在启动开门”

} else {

Serial.println("STATUS:CLOSING");

digitalWrite(RPWM_PIN, HIGH);

digitalWrite(LPWM_PIN, LOW);

currentMotorState = STARTING_CLOSE; // 设置初始状态为“正在启动关门”

}

}

  

// 停止电机

void stopMotor() {

digitalWrite(RPWM_PIN, LOW);

digitalWrite(LPWM_PIN, LOW);

}

  

// 外部调用的“开门”指令接口

void openDoor() {

Serial.println("指令: 开门 (拉杆收缩)...");

startMotorAction(true);

}

  

// 外部调用的“关门”指令接口

void closeDoor() {

Serial.println("指令: 关门 (拉杆伸展)...");

startMotorAction(false);

}

  

// 获取并打印当前重量

void getWeight() {

// 读取10次平均值让读数更稳定，如果绝对值小于20克则视为0，以过滤传感器噪声

float weight = scale.get_units(10); if (abs(weight) < 20) { weight = 0.0; }

Serial.print("当前重量: "); Serial.print(weight, 1); Serial.println(" g");

}

// 启动校准流程，并打印提示信息

void startCalibration() {

Serial.println("\n--- 开始校准流程 ---"); Serial.println("1. 请确保秤盘清空。"); scale.tare();

Serial.print("2. 已去皮。请将 "); Serial.print(CALIBRATION_STANDARD_WEIGHT, 1); Serial.println("g 的标准物品放在秤盘上。");

Serial.println("3. 放置好后，请输入指令 'save_cal' 来保存。");

}

// 保存校准结果到Flash

void saveCalibration() {

// 读取10次平均的原始ADC读数

long raw_reading = scale.get_value(10);

// 计算新的校准系数：系数 = 原始读数 / 标准重量

calibration_factor = (float)raw_reading / CALIBRATION_STANDARD_WEIGHT;

// 将新系数应用到传感器对象

scale.set_scale(calibration_factor);

// 将新系数永久保存到Flash中

preferences.putFloat("cal_factor", calibration_factor);

Serial.print("校准完成！新系数 "); Serial.print(calibration_factor);Serial.println(" 已被永久保存。");

}
```