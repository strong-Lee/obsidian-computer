```c++
#include "HX711.h" // 引入HX711称重传感器库

#include <Preferences.h> // 引入ESP32的Flash非易失性存储库，用于永久保存校准系数

#include <esp_task_wdt.h> // 引入ESP32的任务看门狗库，防止程序卡死

// #include "DFRobotDFPlayerMini.h" // 引入DFPlayer库

// #include "HardwareSerial.h" // 引入硬件串口库

#include <Wire.h> // I2C通信基础库-测距模块使用

#include "Adafruit_VL53L0X.h" // VL53L0X库-测距模块使用

  

// --- 硬件引脚定义 ---

// #define RX2_PIN 16 // DFPlayer连接到ESP32的RX2引脚

// #define TX2_PIN 17 // DFPlayer连接到ESP32的TX2引脚

#define RPWM_PIN 18 // 电机驱动板的正转信号引脚-1号拉杆模块

#define LPWM_PIN 19 // 电机驱动板的反转信号引脚-1号拉杆模块

#define I2C_SDA_PIN 21 // ESP32默认I2C数据引脚-测距模块使用-1号测距模块

#define I2C_SCL_PIN 22 // ESP32默认I2C时钟引脚-测距模块使用-1号测距模块

#define R_IS_PIN 34 // 电流检测引脚：对应伸展/关门动作 (R_IS)-1号拉杆模块

#define L_IS_PIN 35 // 电流检测引脚：对应收缩/开门动作 (L_IS)-1号拉杆模块

#define LOADCELL_DOUT_PIN 25 // HX711称重传感器的数据输出引脚 (DT)-1号称重模块

#define LOADCELL_SCK_PIN 26 // HX711称重传感器的时钟引脚 (SCK)-1号称重模块

  

// --- 核心参数 ---

#define WDT_TIMEOUT 60 // 【可调】看门狗超时时间(秒)，如果60秒内主循环没响应，系统会自动重启

#define TRAVEL_TIME 5500 // 【可调】拉杆从一端到另一端的完整行程时间(毫秒)

#define STARTUP_TIMEOUT 500 // 【可调】电机启动后，检测电流是否出现的超时时间(毫秒)

#define END_CONFIRM_COUNT 8 // 【可调】行程结束时，需要连续检测到多少次“零电流”才算真正停止

#define MIN_RUNNING_CURRENT 50 // 【可调】判断电机是否在“运行”的最低电流ADC读数阈值

#define EXTEND_ABNORMAL_CURRENT 7000 // 【可调】伸展(关门)时的异常大电流保护阈值 (ADC读数)

#define RETRACT_ABNORMAL_CURRENT 7000 // 【可调】收缩(开门)时的异常大电流保护阈值 (ADC读数)

#define CALIBRATION_STANDARD_WEIGHT 217.0 // 【重要】用于校准的砝码重量(克)，这里用的是一个苹果手机的重量

#define DEFAULT_CAL_FACTOR 420.0 // 【可调】默认校准系数(如果从未校准过)

#define WEIGHT_SAMPLE_COUNT 10 // 【可调】称重采样次数(取平均值用)

#define WEIGHT_NOISE_THRESHOLD 20.0 // 【可调】起称阈值(克)，小于此值视为0

#define ENDING_CONFIRM_TIMEOUT 1000 // 【可调】行程结束确认的超时时间(毫秒)

#define POWER_ON_RESET_TIMEOUT 10000 // 【可调】判断为“上电复位”阶段的超时时间(毫秒)

#define DISTANCE_CHECK_INTERVAL 1000 // 【可调】每隔1秒检测一次距离-测距模块使用

// #define DEFAULT_VOLUME 25 // 【可调】默认音量 (0-30)

  

// --- (全局变量和对象创建) ---

float calibration_factor; // 用于存储校准系数

HX711 scale; // 创建一个称重传感器对象

Preferences preferences; // 创建一个Flash存储对象

// DFRobotDFPlayerMini myDFPlayer; // 创建一个DFPlayer对象

// HardwareSerial PlayerSerial(2); // 使用ESP32的第二个硬件串口(Serial2)

Adafruit_VL53L0X lox = Adafruit_VL53L0X(); // 创建一个VL53L0X对象-测距模块使用

unsigned long lastDistanceCheck = 0; // 上次检测距离的时间戳-测距模块使用

  

// --- 模块健康状态标志 ---

// bool isPlayerReady = false; // MP3播放器是否就绪

bool isLoxReady = false; // 激光测距是否就绪

bool isScaleReady = false; // 称重模块是否就绪 (用于初始检查)

  

// --- (状态机核心变量) ---

// 定义电机所有可能的状态

enum MotorState {

IDLE, // 空闲

STARTING_OPEN, // 正在启动开门

RUNNING_OPEN, // 正在运行开门

ENDING_OPEN, // 正在结束开门

STARTING_CLOSE, // 正在启动关门

RUNNING_CLOSE, // 正在运行关门

ENDING_CLOSE // 正在结束关门

};

// 定义一个变量来存储电机当前的状态，程序启动时默认为空闲

MotorState currentMotorState = IDLE;

  

// 时间戳变量，用于非阻塞式延时和超时判断

unsigned long motorActionStartTime = 0; // 记录整个电机动作（从启动到结束）的起始时间戳

unsigned long stateChangeTime = 0; // 记录每次状态切换时的时间戳

  

// 用于结束确认的计数器

int zero_counter = 0;

  

// --- (函数声明) ---

void stopMotor();

void startMotorAction(bool isOpening); // “启动任务”的函数

void updateMotorState(); // “更新状态”的核心函数

// 状态处理函数

void handleStartingOpenState();

void handleRunningOpenState();

void handleEndingOpenState();

void handleStartingCloseState();

void handleRunningCloseState();

void handleEndingCloseState();

// 操作函数

void openDoor();

void closeDoor();

void getWeight();

void startCalibration();

void saveCalibration();

// void playVoice(int trackNumber); // 播放指定编号的语音

void getDistance(); // 激光测距

  

void setup() {

Serial.begin(115200);

Serial.println("\n\n智能回收柜控制系统 v9.4");

  

// --- 初始化 MP3 ---

// PlayerSerial.begin(9600, SERIAL_8N1, RX2_PIN, TX2_PIN);

// if (myDFPlayer.begin(PlayerSerial, true, 1000)) {

// Serial.println("DFPlayer 初始化成功.");

// myDFPlayer.volume(DEFAULT_VOLUME);

// isPlayerReady = true; // [防火墙] 模块健康，设置标志位

// //playVoice(VOICE_WELCOME);

// } else {

// Serial.println("严重警告: 无法连接到DFPlayer！语音功能将禁用。");

// isPlayerReady = false; // [防火墙] 模块故障，设置标志位

// }

  

// 初始化并启动看门狗

esp_task_wdt_config_t wdt_config = {

.timeout_ms = WDT_TIMEOUT * 1000, // 超时时间，单位是毫秒

.idle_core_mask = (1 << 0) | (1 << 1), // 监控两个核心的空闲任务

.trigger_panic = true, // 超时后触发内核恐慌（重启）

};

esp_task_wdt_init(&wdt_config); // 传入配置结构体的地址

esp_task_wdt_add(NULL); // 将当前任务(loop)添加到看门狗监控列表

  

// --- 初始化Flash存储 ---

preferences.begin("trash-cal", false); // 打开名为"trash-cal"的存储空间

// 读取之前保存的校准系数，如果不存在，则使用一个默认值420.0

calibration_factor = preferences.getFloat("cal_factor", 420.0);

Serial.print("校准系数已加载: "); Serial.println(calibration_factor);

  

// --- 初始化称重传感器 ---

scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN); // 启动传感器

if (scale.is_ready()) { // [防火墙] 初始健康检查

Serial.println("称重传感器 初始化成功.");

isScaleReady = true;

scale.set_scale(calibration_factor); // 设置校准系数

scale.tare(); // 开机去皮，将当前重量清零

} else {

Serial.println("严重警告: 无法连接到称重传感器！称重功能将禁用。");

isScaleReady = false;

}

  

// --- 初始化激光测距 ---

Wire.begin(I2C_SDA_PIN, I2C_SCL_PIN); // 初始化I2C总线

Serial.println("正在进行I2C总线快速安全检查...");

unsigned long i2c_check_start = millis();

bool device_found = false;

while (millis() - i2c_check_start < 200) { // 设置一个200毫秒的软件超时

Wire.beginTransmission(0x29); // 0x29是VL53L0X的默认地址

if (Wire.endTransmission() == 0) {

device_found = true; // 找到了！

break; // 立刻跳出循环

}

delay(10); // 短暂延时，再次尝试

}

  

if (device_found) {

Serial.println("快速检查通过。正在尝试初始化VL53L0X...");

if (lox.begin()) {

Serial.println("VL53L0X 初始化成功.");

isLoxReady = true;

} else {

Serial.println("严重警告: VL53L0X应答但库初始化失败！测距功能禁用。");

isLoxReady = false;

}

} else {

Serial.println("严重警告: I2C总线快速检查失败 (超时或无应答)！");

Serial.println("很可能存在硬件短路或接线错误。测距功能将禁用。");

isLoxReady = false;

}

  

// --- 初始化电机引脚 ---

pinMode(RPWM_PIN, OUTPUT);

pinMode(LPWM_PIN, OUTPUT);

stopMotor(); // 确保开机时电机是停止的

  

// --- 执行上电复位程序 ---

Serial.println("系统初始化完成。正在执行上电复位...");

startMotorAction(false); // false代表启动一个“关门”任务

}

  

void loop() {

// 1. 喂狗：每次循环都重置看门狗计时器，表示程序运行正常

esp_task_wdt_reset();

  

// 2. 检查串口指令 (非阻塞)：检查电脑是否发来新指令

if (Serial.available() > 0) {

String command = Serial.readStringUntil('\n'); command.trim();

if (command == "open") { openDoor(); }

else if (command == "close") { closeDoor(); }

else if (command == "weight") { getWeight(); }

else if (command == "start_cal") { startCalibration(); }

else if (command == "save_cal") { saveCalibration(); }

// else if (command.startsWith("play ")) {

// int track = command.substring(5).toInt();

// playVoice(track);

// }

else if (command == "dist") { getDistance(); }

else { Serial.println("未知指令!"); }

}

  

// 3. 更新电机的状态 (整个状态机的核心驱动！)

updateMotorState();

  

// 4. 非阻塞式定时检测距离

if (millis() - lastDistanceCheck > DISTANCE_CHECK_INTERVAL) {

lastDistanceCheck = millis();

getDistance();

}

// 5. (未来可以在这里加其他任务，比如更新MP3播放状态，读取激光距离等)

}

  

void updateMotorState() {

// 如果当前电机是空闲的，就什么都不做，直接返回，节省CPU资源

if (currentMotorState == IDLE) {

return;

}

  

// 根据当前的状态，调用对应的处理函数

switch (currentMotorState) {

case STARTING_OPEN: handleStartingOpenState(); break;

case RUNNING_OPEN: handleRunningOpenState(); break;

case ENDING_OPEN: handleEndingOpenState(); break;

case STARTING_CLOSE: handleStartingCloseState(); break;

case RUNNING_CLOSE: handleRunningCloseState(); break;

case ENDING_CLOSE: handleEndingCloseState(); break;

default:

// 理论上不应该进入这里，可以加个日志以防万一

break;

}

}

  

// 状态处理函数实现

// --- 开门过程的状态处理 ---

void handleStartingOpenState() {

// 检查：电流是否已超过启动阈值？

if (analogRead(L_IS_PIN) > MIN_RUNNING_CURRENT) {

currentMotorState = RUNNING_OPEN; // 状态切换：启动成功 -> 运行中

stateChangeTime = millis(); // 记录进入运行状态的时间点

// 检查：启动是否已超时？

} else if (millis() - motorActionStartTime > STARTUP_TIMEOUT) {

stopMotor();

currentMotorState = IDLE; // 状态切换：回到空闲

Serial.println("REPORT:ERROR_STARTUP_FAILED");

}

}

  

void handleRunningOpenState() {

// 检查：是否出现异常大电流？

if (analogRead(L_IS_PIN) > RETRACT_ABNORMAL_CURRENT) {

stopMotor();

currentMotorState = IDLE;

Serial.println("REPORT:ERROR_ABNORMAL_CURRENT");

// 检查：是否已达到预设的行程时间？

} else if (millis() - motorActionStartTime > TRAVEL_TIME) {

currentMotorState = ENDING_OPEN; // 状态切换：运行中 -> 结束确认

stateChangeTime = millis(); // 记录进入结束确认状态的时间点

zero_counter = 0; // 清零计数器

}

}

  

void handleEndingOpenState() {

// 检查：电流是否已回落到阈值以下？

if (analogRead(L_IS_PIN) < MIN_RUNNING_CURRENT) {

zero_counter++; // 是，则计数器加一

} else {

zero_counter = 0; // 否，则清零计数器，防止误判

}

// 检查：是否已连续多次检测到低电流？

if (zero_counter >= END_CONFIRM_COUNT) {

stopMotor();

currentMotorState = IDLE;

Serial.println("REPORT:DOOR_OPENED");

// 检查：结束确认过程是否已超时？

} else if (millis() - stateChangeTime > ENDING_CONFIRM_TIMEOUT) {

stopMotor();

currentMotorState = IDLE;

Serial.println("REPORT:ERROR_TIMEOUT");

}

}

  

// --- 关门过程的状态处理 (逻辑与开门对称) ---

void handleStartingCloseState() {

if (analogRead(R_IS_PIN) > MIN_RUNNING_CURRENT) {

currentMotorState = RUNNING_CLOSE;

stateChangeTime = millis();

} else if (millis() - motorActionStartTime > STARTUP_TIMEOUT) {

stopMotor();

currentMotorState = IDLE;

// 特殊判断：如果是刚开机时的复位失败，打印更详细的警告

if (millis() < POWER_ON_RESET_TIMEOUT) {

Serial.println("严重警告: 上电复位失败 (电机启动无反应)！");

} else {

Serial.println("REPORT:ERROR_STARTUP_FAILED");

}

}

}

  

void handleRunningCloseState() {

if (analogRead(R_IS_PIN) > EXTEND_ABNORMAL_CURRENT) {

stopMotor();

currentMotorState = IDLE;

Serial.println("REPORT:ERROR_ABNORMAL_CURRENT");

} else if (millis() - motorActionStartTime > TRAVEL_TIME) {

currentMotorState = ENDING_CLOSE;

stateChangeTime = millis();

zero_counter = 0;

}

}

  

void handleEndingCloseState() {

if (analogRead(R_IS_PIN) < MIN_RUNNING_CURRENT) {

zero_counter++;

} else {

zero_counter = 0;

}

if (zero_counter >= END_CONFIRM_COUNT) {

stopMotor();

currentMotorState = IDLE;

// 特殊判断：如果是刚开机时的复位成功，打印更友好的提示

if (millis() < POWER_ON_RESET_TIMEOUT) {

Serial.println("上电复位成功: 门已确认关闭。");

} else {

Serial.println("REPORT:DOOR_CLOSED");

}

} else if (millis() - stateChangeTime > ENDING_CONFIRM_TIMEOUT) {

stopMotor();

currentMotorState = IDLE;

Serial.println("REPORT:ERROR_TIMEOUT");

}

}

  

/**

* @brief 启动一个电机动作（开门或关门）

* @param isOpening true代表开门，false代表关门

*/

void startMotorAction(bool isOpening) {

// 如果电机当前正在忙，则拒绝新指令，防止指令冲突

if (currentMotorState != IDLE) {

Serial.println("电机正忙，请稍后...");

return;

}

motorActionStartTime = millis(); // 记录任务开始的总时间戳

  

if (isOpening) {

Serial.println("STATUS:OPENING");

digitalWrite(RPWM_PIN, LOW);

digitalWrite(LPWM_PIN, HIGH);

currentMotorState = STARTING_OPEN; // 设置初始状态为“正在启动开门”

} else {

Serial.println("STATUS:CLOSING");

digitalWrite(RPWM_PIN, HIGH);

digitalWrite(LPWM_PIN, LOW);

currentMotorState = STARTING_CLOSE; // 设置初始状态为“正在启动关门”

}

}

  

// 停止电机

void stopMotor() {

digitalWrite(RPWM_PIN, LOW);

digitalWrite(LPWM_PIN, LOW);

}

  

// 外部调用的“开门”指令接口

void openDoor() {

Serial.println("指令: 开门 (拉杆收缩)...");

startMotorAction(true);

}

  

// 外部调用的“关门”指令接口

void closeDoor() {

Serial.println("指令: 关门 (拉杆伸展)...");

startMotorAction(false);

}

  

// 获取并打印当前重量

void getWeight() {

// [防火墙] 每次读数前都检查模块是否就绪，这是最安全的方式

if (!scale.is_ready()) {

Serial.println("错误: 无法读取重量，称重传感器未响应!");

return;

}

// 读取10次平均值让读数更稳定，如果绝对值小于20克则视为0，以过滤传感器噪声

float weight = scale.get_units(WEIGHT_SAMPLE_COUNT);

if (abs(weight) < WEIGHT_NOISE_THRESHOLD) {

weight = 0.0;

}

Serial.print("当前重量: "); Serial.print(weight, 1); Serial.println(" g");

}

// 启动校准流程，并打印提示信息

void startCalibration() {

Serial.println("\n--- 开始校准流程 ---"); Serial.println("1. 请确保秤盘清空。"); scale.tare();

Serial.print("2. 已去皮。请将 "); Serial.print(CALIBRATION_STANDARD_WEIGHT, 1); Serial.println("g 的标准物品放在秤盘上。");

Serial.println("3. 放置好后，请输入指令 'save_cal' 来保存。");

}

// 保存校准结果到Flash

void saveCalibration() {

// [防火墙] 保存前同样需要检查

if (!scale.is_ready()) {

Serial.println("错误: 无法校准，称重传感器未响应!");

return;

}

// 读取10次平均的原始ADC读数

long raw_reading = scale.get_value(WEIGHT_SAMPLE_COUNT);

// 计算新的校准系数：系数 = 原始读数 / 标准重量

calibration_factor = (float)raw_reading / CALIBRATION_STANDARD_WEIGHT;

// 将新系数应用到传感器对象

scale.set_scale(calibration_factor);

// 将新系数永久保存到Flash中

preferences.putFloat("cal_factor", calibration_factor);

Serial.print("校准完成！新系数 "); Serial.print(calibration_factor);Serial.println(" 已被永久保存。");

}

  

// /**

// * @brief 播放指定编号的语音，并带有健壮性检查

// * @param trackNumber 要播放的mp3文件编号 (例如: 1 对应 mp3/0001.mp3)

// */

// void playVoice(int trackNumber) {

// // [防火墙] 如果模块未就绪，直接返回，不执行任何操作

// if (!isPlayerReady) {

// return;

// }

// // 健壮性检查：如果传入的编号无效(小于等于0)，则播放默认的欢迎语音

// if (trackNumber <= 0) {

// Serial.print("警告: 收到无效的语音编号, 播放默认欢迎语音...");

// //myDFPlayer.playMp3Folder(VOICE_WELCOME); // playMp3Folder是更可靠的播放方式

// } else {

// Serial.print("正在播放语音编号: "); Serial.println(trackNumber);

// myDFPlayer.playMp3Folder(trackNumber);

// }

// }

  

// 激光测距

void getDistance() {

// [防火墙] 如果模块未就绪，直接返回

if (!isLoxReady) {

return;

}

VL53L0X_RangingMeasurementData_t measure;

lox.rangingTest(&measure, false); // 启动一次测量

  

if (measure.RangeStatus != 4) { // status=4代表超出范围

Serial.print("距离: "); Serial.print(measure.RangeMilliMeter); Serial.println(" mm");

} else {

Serial.println("超出范围");

}

}
```