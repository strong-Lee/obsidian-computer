大多数应用都需要存储数据。在K8s中，数据持久化是一个关键且相对复杂的概念。

### 3.1 Kubernetes持久化存储概述

- **问题：** Pod是短暂的，如果Pod被删除或重新调度到其他节点，其内部的数据也会丢失。对于数据库、文件存储等有状态应用，这显然是不可接受的。
    
- **解决方案：** Kubernetes提供了持久卷（[[PersistentVolume]], PV）和持久卷声明（[[PersistentVolumeClaim]], PVC）的抽象。
    
    > [!INFO] PV (PersistentVolume)  
    > 集群中的一块存储资源，由管理员（或存储供应器）预先配置。PV是集群级别的资源，独立于Pod的生命周期。
    
    > [!INFO] PVC (PersistentVolumeClaim)  
    > 用户（开发者）对存储资源的请求。Pod通过PVC来请求存储，而不是直接请求PV。K8s会自动将PVC绑定到符合条件的PV。
    
    > [!INFO] StorageClass (存储类)  
    > 动态配置PV的机制。当PVC请求某种特定类型的存储时，K8s可以根据StorageClass的定义动态创建PV。microk8s enable hostpath-storage 就是创建了一个名为 microk8s-hostpath 的StorageClass。
    
- **对于有状态应用：[[StatefulSet]]**
    
    > [!INFO] 概念与原理
    > 
    > - **概念：** 专门用于管理有状态应用的K8s控制器。它保证了Pod的有序部署、扩展和删除，并为每个Pod提供稳定的网络标识（固定的hostname）和持久存储。
    >     
    > - **为什么是StatefulSet？** 对于MySQL、Redis等数据库，每个实例可能需要唯一的身份和独立的持久存储。StatefulSet通过其有序性和唯一的网络标识解决了这些问题。
    >     
    

### 3.2 部署MySQL数据库

我们将部署一个MySQL数据库作为有状态应用的示例。

**操作步骤：**

1. **创建命名空间：**
    
    ```bash
    kubectl create namespace database
    ```
    
2. **创建MySQL Deployment/StatefulSet YAML：**  
    为了简单起见，这里提供一个基于Deployment的简单MySQL YAML。在生产环境中，**强烈建议使用StatefulSet** 来部署数据库。  
    创建一个 mysql.yaml 文件：
    
    ```yaml
    # mysql.yaml
    apiVersion: v1
    kind: Service
    metadata:
      name: mysql-service
      namespace: database
    spec:
      selector:
        app: mysql
      ports:
        - protocol: TCP
          port: 3306
          targetPort: 3306
      clusterIP: None # headless service，StatefulSet通常需要，这里为方便演示也用上
    ---
    apiVersion: apps/v1
    kind: Deployment # 生产环境建议使用 StatefulSet
    metadata:
      name: mysql-deployment
      namespace: database
    spec:
      selector:
        matchLabels:
          app: mysql
      strategy:
        type: Recreate # 确保旧Pod完全终止后再创建新Pod，避免数据冲突
      template:
        metadata:
          labels:
            app: mysql
        spec:
          containers:
            - name: mysql
              image: mysql:8.0 # 使用MySQL 8.0镜像
              env:
                - name: MYSQL_ROOT_PASSWORD
                  valueFrom: # 使用Secret来安全地存储密码
                    secretKeyRef:
                      name: mysql-secret # Secret的名称
                      key: root_password # Secret中存储密码的key
                - name: MYSQL_DATABASE
                  value: recycle # 默认创建的数据库
              ports:
                - containerPort: 3306
              volumeMounts:
                - name: mysql-persistent-storage
                  mountPath: /var/lib/mysql # MySQL数据目录
          volumes:
            - name: mysql-persistent-storage
              persistentVolumeClaim:
                claimName: mysql-pvc # 引用PVC名称
    ---
    apiVersion: v1
    kind: PersistentVolumeClaim # PVC声明
    metadata:
      name: mysql-pvc
      namespace: database
    spec:
      accessModes:
        - ReadWriteOnce # 只允许单节点读写
      storageClassName: microk8s-hostpath # 引用MicroK8s默认的StorageClass
      resources:
        requests:
          storage: 10Gi # 请求10GB存储空间
    ---
    apiVersion: v1
    kind: Secret # 存储MySQL root密码的Secret
    metadata:
      name: mysql-secret
      namespace: database
    type: Opaque # 简单键值对 Secret
    data:
      root_password: <base64编码的密码> # 例如：echo -n "your_password" | base64
    ```
    
    > [!INFO] YAML解释
    > 
    > - **Service (Headless Service)：** clusterIP: None 表示这是一个无头服务。它不会分配一个ClusterIP，而是为每个后端Pod创建一个DNS记录。这对于StatefulSet中的有序Pod访问非常有用。
    >     
    > - **Deployment vs StatefulSet：**
    >     
    >     - Deployment 适用于无状态应用，每个Pod都是可替换的。
    >         
    >     - StatefulSet 适用于有状态应用，保证Pod的稳定网络标识和有序性，每个Pod有自己独立的持久卷。
    >         
    >     - **在这里使用 Deployment 只是为了简化教程，** 在实际生产环境中，**部署MySQL等有状态数据库务必使用 StatefulSet**。
    >         
    > - **MYSQL_ROOT_PASSWORD：** 这里使用了[[Kubernetes Secret]]来存储密码。在生产环境，这是**非常推荐且安全**的做法。
    >     
    >     - **创建Secret：** 密码需要Base64编码。例如，要存储密码 mypassword，先运行 echo -n "mypassword" | base64 得到编码后的字符串，然后填入YAML。
    >         
    > - **storageClassName: microk8s-hostpath：** 这是我们在 microk8s enable hostpath-storage 时创建的默认StorageClass。它会将数据持久化到VM的 /var/snap/microk8s/common/var/lib/hostpath/ 目录下。
    >     
    > - **accessModes: ReadWriteOnce：** 表示这个卷只能被单个Pod以读写模式挂载。对于数据库这类应用通常足够。
    >     
    
3. **应用MySQL配置：**
    
    ```bash
    kubectl apply -f mysql.yaml
    ```
    
    
4. **检查MySQL状态：**
    
    ```bash
    kubectl get deployment -n database
    kubectl get pods -n database -o wide
    kubectl get svc -n database
    kubectl get pvc -n database
    kubectl get secret -n database mysql-secret -o yaml # 确认Secret已创建且内容正确
    ```
    
    确保Pod、PVC和Secret都处于 Running 或 Bound 状态。
    
5. **访问MySQL数据库：**
    
    - **从K8s内部访问（推荐）：**
        
        
        ```bash
        # 找到MySQL Pod的名称
        kubectl get pods -n database -l app=mysql
        # 进入MySQL Pod的Shell
        kubectl exec -it -n database <mysql-pod-name> -- sh
        # 连接MySQL客户端
        mysql -uroot -p<your_password> # 注意：-p后直接跟密码，无空格，或者只写-p然后回车输入
        # 进入数据库
        use recycle;
        # 导入SQL文件（如果您有的话）
        # kubectl cp /path/to/my.sql database/<mysql-pod-name>:/tmp/my.sql -n database
        # CREATE DATABASE recycle;
        # use recycle;
        # SOURCE /tmp/my.sql;
        ```
        
    - **从K8s外部访问（不推荐用于生产）：**  
        您可以像Nginx一样，为MySQL Service暴露一个 [[#NodePort|NodePort]] 或 LoadBalancer。但直接暴露数据库到外部是非常不安全的。通常，数据库只应从集群内部的应用访问。  
        如果仅为测试目的，可以通过 kubectl port-forward 临时将数据库端口转发到本地：
        
        ```bash
        kubectl port-forward --namespace database svc/mysql-service 3306:3306 & # 在后台运行
        # 现在您可以在宿主机上通过 localhost:3306 连接MySQL
        mysql -h 127.0.0.1 -P 3306 -uroot -p<your_password>
        ```
        
        > [!INFO] 原理  
        > kubectl port-forward 在您的本地机器和集群内的Pod之间建立一个隧道，流量通过这个隧道转发，使得您可以像访问本地服务一样访问集群内的服务。这仅用于调试和临时访问，不适用于生产环境。
        
6. **修改MySQL配置文件：**  
    您原文档中的 kubectl cp 命令是修改容器内部文件的好方法。
    
    > [!SUCCESS] 优点  
    > 可以在不重新构建镜像的情况下，临时修改容器内的配置文件。
    
    > [!FAILURE] 缺点  
    > 这种修改是**临时的且非持久化**的。当Pod被重建时（例如，Deployment更新、节点故障），修改会丢失。
    
    > [!TIP] 最佳实践（生产）  
    > 对于持久化的配置修改，应将配置文件挂载为[[ConfigMap]]或[[Kubernetes Secret]]卷，或者重新构建包含修改后配置的Docker镜像。
    
    ```bash
    # 将容器内的my.cnf复制到本地
    kubectl cp database/<mysql-pod-name>:/etc/my.cnf ./my.cnf -n database
    # 编辑本地的my.cnf
    vim my.cnf
    # 将修改后的my.cnf复制回容器
    kubectl cp ./my.cnf database/<mysql-pod-name>:/etc/my.cnf -n database
    # 重启Pod使配置生效（通常需要删除Pod，让Deployment自动重建）
    kubectl delete pod <mysql-pod-name> -n database
    ```
    
### 3.3 部署Redis数据库 (无密码/有密码)

我们将部署一个Redis数据库，并演示如何处理密码。

**操作步骤：**

1. **创建Redis Deployment/StatefulSet YAML：**  
    创建一个 redis.yaml 文件。同样，在生产环境**强烈建议使用StatefulSet**。
    
    ```yaml
    # redis.yaml
    apiVersion: v1
    kind: Service
    metadata:
      name: my-redis-master
      namespace: default # 可以选择默认命名空间或创建新的
      labels:
        app: redis
        role: master
    spec:
      ports:
      - port: 6379
        targetPort: 6379
      selector:
        app: redis
        role: master
    ---
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: my-redis-master
      namespace: default
      labels:
        app: redis
        role: master
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: redis
          role: master
      template:
        metadata:
          labels:
            app: redis
            role: master
        spec:
          containers:
          - name: master
            image: docker.io/bitnami/redis:7.2.4-debian-12-r9 # Bitnami提供了好用的带密码功能的Redis镜像
            env:
              - name: ALLOW_EMPTY_PASSWORD
                value: "no" # 不允许空密码
              - name: REDIS_PASSWORD
                valueFrom:
                  secretKeyRef:
                    name: my-redis-secret # Secret名称
                    key: redis-password  # Secret中密码的key
            ports:
            - containerPort: 6379
            volumeMounts:
            - name: redis-data
              mountPath: /bitnami/redis/data # Bitnami镜像的数据目录
          volumes:
            - name: redis-data
              persistentVolumeClaim:
                claimName: redis-pvc
    ---
    apiVersion: v1
    kind: PersistentVolumeClaim
    metadata:
      name: redis-pvc
      namespace: default
    spec:
      accessModes:
        - ReadWriteOnce
      storageClassName: microk8s-hostpath
      resources:
        requests:
          storage: 1Gi # Redis通常不需要太大空间
    ---
    apiVersion: v1
    kind: Secret
    metadata:
      name: my-redis-secret
      namespace: default
    type: Opaque
    data:
      redis-password: <base64编码的redis密码> # 例如：echo -n "myredispass" | base64
    ```
    
    > [!INFO] YAML解释
    > 
    > - docker.io/bitnami/redis: Bitnami的Redis镜像提供了更丰富的功能和配置选项，包括方便的密码设置。
    >     
    > - ALLOW_EMPTY_PASSWORD: "no" 和 REDIS_PASSWORD：配合[[Kubernetes Secret]]安全设置Redis密码。
    >     
    > - my-redis-master Service和Deployment：这是一个简单的单点Redis部署。对于高可用，需要[[StatefulSet]]和Redis Sentinel/Cluster。
    >     
    
2. **应用Redis配置：**
    
    ```bash
    kubectl apply -f redis.yaml
    ```
    
3. **获取Redis密码：**
    
    
    ```bash
    export REDIS_PASSWORD=$(kubectl get secret --namespace default my-redis-secret -o jsonpath="{.data.redis-password}" | base64 -d)
    echo $REDIS_PASSWORD # 验证密码是否正确
    ```
    
4. **连接到Redis服务器：**
    
    - **方法一：运行一个Redis客户端Pod**
        
        ```bash
        # 运行一个临时的Redis客户端Pod
        kubectl run --namespace default redis-client --restart='Never' \
            --env REDIS_PASSWORD=$REDIS_PASSWORD \
            --image docker.io/bitnami/redis:7.2.4-debian-12-r9 \
            --command -- sleep infinity
        
        # 连接到客户端Pod的Shell
        kubectl exec --tty -i redis-client --namespace default -- bash
        
        # 在客户端Pod内使用Redis CLI连接
        REDISCLI_AUTH="$REDIS_PASSWORD" redis-cli -h my-redis-master
        # 如果有从节点，可以连接到从节点服务 (假设您有 replicaset 配置)
        # REDISCLI_AUTH="$REDIS_PASSWORD" redis-cli -h my-redis-replicas
        ```
        
    - **方法二：从集群外部通过端口转发连接**
        
        ```bash
        kubectl port-forward --namespace default svc/my-redis-master 6379:6379 & # 在后台转发
        REDISCLI_AUTH="$REDIS_PASSWORD" redis-cli -h 127.0.0.1 -p 6379
        ```
        
        > [!NOTE] 这种方式同样只用于测试和调试，不用于生产环境。