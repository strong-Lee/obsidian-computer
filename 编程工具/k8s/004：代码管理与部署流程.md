在K8s中，最佳实践是将您的应用程序打包成Docker镜像。然而，在开发阶段，您可能需要更灵活的方式来同步代码。

### 4.1 本地代码挂载到虚拟机 (Multipass Mount)

> [!SUCCESS] 优点
> 
> - **实时同步：** 代码修改后，立即在虚拟机中生效，无需手动复制或重新部署。
>     
> - **开发便利：** 模拟本地开发环境，方便调试。
>     

> [!FAILURE] 缺点
> 
> - **仅限开发/测试：** 不适用于生产环境，因为这是直接将宿主机目录挂载到VM，如果VM崩溃或迁移，挂载点会失效。
>     
> - **性能开销：** 大量文件操作可能导致性能下降。
>     

**操作步骤：**

1. **挂载本地目录到VM：**
    
    ```bash
    multipass mount /Users/cay/www/aila/api microk8s-vm:/home/ubuntu/www/api
    multipass mount /Users/cay/www/aila/business-middle-office microk8s-vm:/home/ubuntu/www/business-middle-office
    ```
    
    > [!INFO] 命令解释与原理
    > 
    > - **multipass mount <local_path> <vm_name>:<vm_path>：** 将宿主机（local_path）的目录挂载到指定VM（vm_name）的路径（vm_path）。
    >     
    > - **原理：** Multipass在底层使用类似VirtioFS或9P的文件共享协议，在宿主机和虚拟机之间建立一个共享文件系统。
    >     
    
2. **验证挂载：**  
    进入虚拟机Shell (multipass shell microk8s-vm)，使用 ls /home/ubuntu/www/api 或 mount 命令查看。
    
3. **解除挂载：**
    
    ```bash
    multipass unmount microk8s-vm:/home/ubuntu/www/api
    ```
    
### 4.2 通过 multipass transfer 复制文件

> [!SUCCESS] 优点
> 
> - **简单直接：** 适用于一次性文件传输，或传输不频繁更新的文件。
>     
> - **比挂载更可靠：** 文件是实际复制到VM中，与宿主机解耦。
>     

> [!FAILURE] 缺点
> 
> - **非实时同步：** 每次修改都需要重新复制。
>     

**操作步骤：**

```bash
multipass transfer -r /Users/cay/www/code_php/hawk microk8s-vm:/home/ubuntu/www/
# scp -r /Users/cay/www/aila ubuntu@192.168.64.2:/home/ubuntu/www # scp 方式
```

- **multipass transfer -r <local_path> <vm_name>:<vm_path>：** -r 表示递归复制目录。
    

### 4.3 K8s部署代码的最佳实践：Docker镜像

尽管上述方法方便开发，但**生产环境务必将应用代码打包成Docker镜像**，并通过[[Deployment]]/[[StatefulSet]]部署。

> [!INFO] 理由
> 
> - **一致性：** 镜像包含了所有依赖，确保应用在任何K8s环境中运行行为一致。
>     
> - **隔离性：** 容器提供了良好的进程和文件系统隔离。
>     
> - **可移植性：** 镜像可以在任何支持Docker的机器上运行。
>     
> - **版本控制：** 镜像标签提供了清晰的应用版本管理。
>     
> - **快速部署：** K8s只需拉取镜像并启动容器。
>     
> - **安全性：** 可以对镜像进行安全扫描。
>     

**示例：部署您的PHP应用 (以Docker镜像为例)**

如果您已经将PHP代码和环境打包成了Docker镜像（例如 your-php-app:v1.0），则可以在K8s中部署：

1. **创建PHP应用Deployment YAML (iot-api.yaml / business-middle-office.yaml):**
    
    ```yaml
    # iot-api.yaml 示例
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: iot-api-service
      namespace: aila
    spec:
      replicas: 2 # 示例：2个副本，实现高可用
      selector:
        matchLabels:
          app: iot-api
      template:
        metadata:
          labels:
            app: iot-api
        spec:
          containers:
          - name: iot-api
            image: your-private-registry/iot-api:latest # 替换为你的镜像路径
            ports:
            - containerPort: 80 # 假设PHP-FPM+Nginx或PHP内置Web服务器监听80
            # 资源请求与限制，非常重要！
            resources:
              requests: # K8s调度时参考，保证Pod能获得最低资源
                cpu: 200m # 20% of a CPU core
                memory: 256Mi # 256 MB
              limits: # Pod最大可使用资源，超出会被OOMKill或限流
                cpu: 500m
                memory: 512Mi
            # 环境变量，例如数据库连接信息
            env:
            - name: DB_HOST
              value: mysql-service.database.svc.cluster.local # K8s服务发现，服务名.命名空间.svc.cluster.local
            - name: DB_USER
              valueFrom:
                secretKeyRef:
                  name: mysql-credentials # 从Secret获取
                  key: username
            - name: DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysql-credentials
                  key: password
          # 如果您的应用需要文件存储，可以使用PVC或NFS挂载
          # volumes:
          # - name: app-data
          #   persistentVolumeClaim:
          #     claimName: iot-api-pvc
    ```
    
    > [!INFO] YAML解释与原理
    > 
    > - **replicas: 2：** 表示您希望K8s始终运行2个Pod副本。这是实现应用高可用和负载均衡的基础。
    >     
    > - **resources.requests & resources.limits：** **非常关键！**
    >     
    >     - **requests：** 告诉K8s调度器，这个Pod至少需要多少CPU和内存才能正常运行。调度器会尽量将Pod调度到有足够空闲资源的节点上。
    >         
    >     - **limits：** 设置Pod可使用的CPU和内存的上限。如果Pod尝试使用超过limit的CPU，它会被限流；如果尝试使用超过limit的内存，它会被Killed (OOMKill)。
    >         
    > - **为什么这么做？**
    >     
    >     - **稳定性：** 防止某个Pod耗尽节点资源，影响同节点上其他Pod的性能和稳定性。
    >         
    >     - **调度优化：** K8s调度器根据requests来决定将Pod放置在哪个节点，确保节点有足够的资源。
    >         
    >     - **性能保证：** 保证Pod能够获得其所需的最少资源，避免资源争抢导致的性能下降。
    >         
    >     - **资源利用率：** 更好的资源规划和利用。
    >         
    > - **环境变量 (env / envFrom)：** 将配置信息（如数据库地址、密码）通过环境变量注入到容器中。valueFrom 结合 [[Kubernetes Secret]] 是推荐的安全做法。
    >     
    > - **服务发现：mysql-service.database.svc.cluster.local**
    >     
    >     - 这是K8s内部[[Service]]的完整DNS名称。mysql-service 是Service名称，database 是命名空间，svc.cluster.local 是集群域后缀。
    >         
    >     - **原理：** K8s内部的[[CoreDNS]]服务会将这个域名解析为 mysql-service 的ClusterIP，从而实现应用与数据库之间的通信，无需硬编码IP地址。
    >         
    
2. **创建Service和Ingress (如果需要外部访问):**
    
    ```yaml
    # iot-api-service.yaml 示例
    apiVersion: v1
    kind: Service
    metadata:
      name: iot-api-service
      namespace: aila
    spec:
      selector:
        app: iot-api
      ports:
        - protocol: TCP
          port: 80
          targetPort: 80
    ---
    apiVersion: networking.k8s.io/v1
    kind: Ingress
    metadata:
      name: iot-api-ingress
      namespace: aila
    spec:
      rules:
      - host: api.example.com
        http:
          paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: iot-api-service
                port:
                  number: 80
    ```
    
3. **应用这些YAML文件：**
    
    ```yaml
    kubectl create namespace aila
    kubectl apply -f iot-api.yaml
    kubectl apply -f iot-api-service.yaml
    ```
    
4. **查看日志和进入Pod调试：**
    
    ```bash
    microk8s kubectl logs --tail 200 -n aila -f iot-api-service-<pod-hash> # 查看应用日志
    microk8s kubectl exec -it -n aila iot-api-service-<pod-hash> -- bash # 进入应用Pod的Shell
    ```
    
    > [!INFO] 命令解释
    > 
    > - **kubectl logs -f：** 实时跟踪Pod日志。
    >     
    > - **kubectl exec -it -- bash：** 在运行中的容器内部执行命令，常用于调试、检查文件、执行脚本。
    >